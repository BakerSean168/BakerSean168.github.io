---
title: JS中的模块模式
categories:
  - JavaScript
description: JS中的模块模式
date: 2025-01-18 16:19:03
tags:
---

# 模块模式

## 是什么

### 核心思想

把逻辑分块，各自封装，相互独立，每个块自行决定对外暴露什么，同时自行决定引入执行哪些外部代码。

要解决的问题：

- 作用域隔离
- 私有共有分离
- 可复用

## 模块的关键点

### 模块标识符

模块标识符是所有模块系统通用的概念。  
模块系统本质上是键/值实体，其中每个模块都有个可用于引用它的标识符。  
这个标识符在模拟模块的系统中可能是字符串，在原生实现的模块系统中可能是模块文件的实际路径。

### 模块依赖

模块系统的核心是管理依赖。  
指定依赖的模块与周围的环境会达成一种契约。  
本地模块向模块系统声明一组外部模块（依赖），这些外部模块对于当前模块正常运行是必需的。  
模块系统检视这些依赖，进而保证这些外部模块能够被加载并在本地模块运行时初始化所有依赖。

### 模块加载

在浏览器中，加载模块涉及几个步骤。

- 加载模块涉及执行其中的代码，但必须是在所有依赖都加载并执行之后。
- 如果浏览器没有收到依赖模块的代码，则必须发送请求并等待网络返回。
- 收到模块代码之后，浏览器必须确定刚收到的模块是否也有依赖。
- 然后递归地评估并加载所有依赖，直到所有依赖模块都加载完成。
- 只有整个依赖图都加载完成，才可以执行入口模块。

### 入口

相互依赖的模块必须指定一个模块作为入口（entry point），这也是代码执行的起点。

### 异步依赖

可以让 JavaScript 通知模块系统在必要时加载新模块，并在模块加载完成后提供回调。

### 动态依赖

允许开发者在程序结构中动态添加依赖。

### 静态分析

模块中包含的发送到浏览器的 JavaScript 代码经常会被静态分析，分析工具会检查代码结构并在不实际执行代码的情况下推断其行为。  
对静态分析友好的模块系统可以让模块打包系统更容易将代码处理为较少的文件。

### 循环依赖

要构建一个没有循环依赖的 JavaScript 应用程序几乎是不可能的，因此包括 CommonJS、AMD 和 ES6 在内的所有模块系统都支持循环依赖。

## 需要了解什么

实现模块模式的方式有很多，现在主要的方式有两种，CommonJS 模块和 ES6 模块

下面主要讲讲两种模块的一些特性。

### CommonJS

- 使用 `require()` 指定依赖，使用 `exports` 定义自己的公共 API
- 无论一个模块在 require()中被引用多少次，模块永远是单例。
- 模块第一次加载后会被缓存，后续加载会取得缓存的模块。
- 模块加载是模块系统执行的同步操作。因此 require()可以以编程方式嵌入在模块中。
- 导入基本数据类型，属于复制，会被模块缓存，可以被重新赋值
- 导入引用数据类型，属于浅拷贝

### ES6

- 导出、导入方式更多，支持只引入必要内容
- 模块第一次加载后会被缓存，后续加载会取得缓存的模块。
- 导入的值是 动态只读引用，不能修改

### 区别

require 会将完整的 exports 对象引入，import 可以只引入必要的内容  
import 没有找到 export 的变量，在执行前就会报错，而 Common.js 在运行时才会报错  
commonJS 输出是值得拷贝 ES6 模块输出是值得引用  
commonJS 是运行时加载， ES6 模式是编译时输出接口  
commonJS require()是同步加载模块，ES6 模块的 import 命令是异步加载，有一个独立的模块依赖的解析阶段
