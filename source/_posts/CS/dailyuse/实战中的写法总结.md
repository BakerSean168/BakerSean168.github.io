---
title: 实战中的写法总结
categories:
  - null
description: 本文章用来记录一下我在完成 DailyUse 项目过程中遇到的一些好用的代码写法。
date: 2025-07-08 09:58:58
tags:
---

### 对象的创建编辑表单

1. 给对象实现 clone（复制一个对象） 和 forCreate（创建一个初始化了基础信息（uuid等）的对象） 方法
2. 给表单传入 对象 | null，再通过 watch 监听对象，如果对象为 null，则创建一个初始对象，否则就 clone 一个对象。
3. 表单与本地对象双向绑定，编辑或创建提交时传递本地对象

修改当前 GoalDialog 使用类似 TemplateDialog 的方式，传入编辑对象的实例（编辑模式）或 null（创建模式），watch visible 和 传入的对象，使用对象的 clone 或 forCreate 方法初始化本地对象，表单与本地对象双向绑定，编辑或创建提交时传递本地对象

### 对象的数据相关方法

- `toDTO()`： 将对象实例转为对象接口数据
- `static fromDTO(dto: T)`： 将对象接口数据转为对象实例
- `clone()`： 创建对象的副本
- `forCreate()`： 创建对象实例，用于创建模式
- `isxxx()`： 判断对象实例是否为xxx对象实例
- `ensurexxx()`： 确保对象实例为xxx对象实例
- `ensurexxxNeverNull()`： 确保对象实例为xxx对象实例，并且不为null

对象属性有些是创建是传入的，有些是对象内部初始化的比如生命周期等（不能在创建时传入，uuid 在forCreate中不需要传入），所以 `clone（）` 等从已有对象创建对象实例时，需要通过constructor 创建实例后再利用 setter 方法设置内部属性。

### 类型断定相关语法糖写法整理

#### 1. 可选链（Optional Chaining）`?.`

用于安全地访问对象的嵌套属性或方法，避免因中间属性为 null/undefined 而报错。

```ts
const arr = systemGroup?.templates;
```
等价于：
```ts
const arr = systemGroup ? systemGroup.templates : undefined;
```

#### 2. 空值合并运算符（Nullish Coalescing）`??`

用于为 null 或 undefined 的值提供默认值。

```ts
const arr = systemGroup?.templates ?? [];
```
等价于：
```ts
const arr = (systemGroup && systemGroup.templates) != null ? systemGroup.templates : [];
```

#### 3. 非空运算符（Non-null Assertion）`!`

用于告诉 TypeScript 忽略 null 或 undefined 的值。

#### 3. 展开运算符（Spread Operator）`...`

用于数组或对象的展开、合并。

```ts
const allTemplates = [...(systemGroup?.templates ?? []), ...otherTemplates];
```

---

### 函数的参数

函数的参数应该采用对象形式：  
- 不需要记住参数顺序，调用时只需写明属性名。
- 可选参数可以省略，不会因顺序错乱导致 bug。
- 代码更易读、易维护，扩展性更好。

### 修改对象的表单

给表单传入 要修改的对象（编辑） || null（创建），直接使用 forCreate（编辑） 或者 clone（创建） 方法来生成一个对象，然后让表单与这个对象双向绑定来修改或创建（每一个属性利用 computed 的 get set 方法来处理），成功后调用相应服务和传入对象。

### Electron 的进程间数据传输遇到问题（无法被克隆）

```
[AccountIpcClient] 发送账号注册请求 Proxy(Object) {username: '123', firstName: '12', lastName: '3', sex: 1}
accountIpcClient.ts:9 📝 [AccountIpcClient] 序列化后的注册数据 {username: '123', firstName: '12', lastName: '3', sex: 1}
```
注意 vue 中的对象数据很有可能是被 代理 的，需要转为普通对象（可以使用 JSON 方法）  

### Ts 在类中使用 pinia 状态的延迟加载

使用 get 方法延迟获取 pinia 状态，否则会报未在 pinia 初始化前就访问 pinia 状态的错。  
ts 是编译时的，所以无法在运行时检查 pinia 状态的访问。  

```ts

private get store() {
  return useReminderStore();
}

```

### 类的懒加载

延迟获取依赖，避免因为静态编译时加载未准备好的依赖。

```ts
class p {
  private _goalStore: ReturnType<typeof useGoalStore> | null = null;

  /**
   * 延迟获取 goalStore，确保 Pinia 已经初始化
   */
  private get goalStore() {
    if (!this._goalStore) {
      this._goalStore = useGoalStore();
    }
    return this._goalStore;
  }

  async addGoal(goal: IGoal): Promise<void> {
    try {
      await this.goalStore.addGoal(goal);
      console.log(`✅ [StateRepo] 添加目标到状态: ${goal.id}`);
    } catch (error) {
      console.error(`❌ [StateRepo] 添加目标失败: ${goal.id}`, error);
      throw error;
    }
  }

  isAvailable(): boolean {
    try {
      // 简单检查 store 是否可用
      return this.goalStore !== null && this.goalStore !== undefined;
    } catch (error) {
      console.error("❌ [StateRepo] 状态仓库不可用", error);
      return false;
    }
  }
}
```

### 类的工厂函数创建实例(异步)+单例+依赖注入（切换不同的创建工厂）

```ts
class AuthenticationLogoutService {
  private static instance: AuthenticationLogoutService;
  private authCredentialRepository: IAuthCredentialRepository;
  constructor(authCredentialRepository: IAuthCredentialRepository) {
    
    this.authCredentialRepository = authCredentialRepository;
  }
  static async createInstance(): Promise<AuthenticationLogoutService> {
    const authenticationContainer = await AuthenticationContainer.getInstance();
    const authCredentialRepository = authenticationContainer.getAuthCredentialRepository();
    return new AuthenticationLogoutService(authCredentialRepository);
  }
  static async getInstance(): Promise<AuthenticationLogoutService> {
    if (!AuthenticationLogoutService.instance) {
      AuthenticationLogoutService.instance = await this.createInstance();
    }
    return AuthenticationLogoutService.instance;
  }

  // 你的 logout 方法等...
}


const logoutService = await AuthenticationLogoutService.createInstance();
```

### 领域服务类

领域服务类，用于处理业务逻辑，封装了领域模型，并定义了领域模型之间的关系。  
领域服务类不直接导入基础设施层（仓库），应该通过应用服务层注入仓库。  

```typescript

```



### 对象属性的表单

Vue 的响应式系统对 class 实例的 getter/setter 支持有限，直接用 class 实例属性做 v-model，只有在 class 内部用 reactive/ref 包裹，或者用 computed 包装，才能保证视图和数据同步。 

```ts
const enableMode = computed({
  get: () => props.templateGroup?.enableMode || 'group',
  set: (val) => {
    if (localTemplateGroup.value) {
      localTemplateGroup.value.enableMode = val;
    }
  }
});
```

### 对象类型变化

TS 中的对象貌似类型会莫名其妙的变化，导致报类型的匹配的错误，需要使用 ensure 函数来确保类型

```ts

<!-- TemplateDialog -->
      <template-dialog
        :model-value="templateDialog.show"
        :template="templateDialog.template" // 这里会报错，要改为下面的参数
        // ReminderTemplate.ensureReminderTemplate(templateDialog.template)
        @update:modelValue="templateDialog.show = $event"
        @submit="handleTemplateDialogSubmit"
        @create-template="handleCreateReminderTemplate"
        @update-template="handleUpdateReminderTemplate"
      />

const templateDialog = ref({
  show: false,
  template: null as ReminderTemplate | null
});

```

## DDD 实践相关

### 聚合根内业务

在 服务方法中先获取对象，参数等，并确保正常，内部方法则利用验证的数据来操作，确保内部不会发生错误  

```ts
/**
  * 添加记录
  */
addRecord(record: Record): void {
  const { keyResultUuid } = record;
  const keyResult = this._keyResults.find((kr) => kr.uuid === keyResultUuid);
  if (keyResult) {
    this.increaseKeyResultProgressByKR(keyResult, record.value);
    this._records.push(record);
    this._lifecycle.updatedAt = new Date();
    this._version++;
  }
}
```

### 仓库实现

实现 mapRowToKeyResult（数据库数据转换成对象）和 mapKeyResultToRow（对象转换成数据库数据）

{
    "uuid": "3271617c-4f41-4a73-96c9-535081ba091d",
    "goalUuid": "05bd7999-f0fe-4746-a263-f3eab8d41e47",
    "title": "",
    "type": "custom",
    "reviewDate": "2025-07-27T15:01:44.646Z",
    "content": {
        "achievements": "2",
        "challenges": "",
        "learnings": "",
        "nextSteps": "3"
    },
    "snapshot": {
        "snapshotDate": "2025-07-27T15:01:44.646Z",
        "overallProgress": 0,
        "weightedProgress": 0,
        "completedKeyResults": 0,
        "totalKeyResults": 0,
        "keyResultsSnapshot": [
            {
                "uuid": "ca8fee17-6fe3-4dc8-b799-7ed8d70fb10e",
                "name": "22222",
                "progress": 0,
                "currentValue": 0,
                "targetValue": 10
            }
        ]
    },
    "rating": {
        "progressSatisfaction": 0,
        "executionEfficiency": 0,
        "goalReasonableness": 0
    },
    "lifecycle": {
        "createdAt": "2025-07-27T15:01:44.647Z",
        "updatedAt": "2025-07-27T15:01:44.647Z"
    }
}