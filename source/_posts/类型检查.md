---
title: 类型检查
categories:
  - null
description: 类型检查
date: 2025-08-06 16:09:08
tags:
---

下面是原代码同时 LoginWindow 有报错：  
Unsafe declaration merging between classes and interfaces.eslint@typescript-eslint/no-unsafe-declaration-merging  

这段代码是 AI 生成的，并不是很清楚它的作用，现在正好遇到了报错，来深入研究一下。  

# 冲突的那段代码有什么用

你注释掉的这段代码：

```typescript
// export declare interface LoginWindow {
//   on<U extends keyof LoginWindowEvents>(
//     event: U,
//     listener: LoginWindowEvents[U]
//   ): this;
//   emit<U extends keyof LoginWindowEvents>(
//     event: U,
//     ...args: Parameters<LoginWindowEvents[U]>
//   ): boolean;
// }
```

### 这段代码的作用

- **本质**：它是 TypeScript 的“声明合并”用法，目的是给 `LoginWindow` 类**补充类型提示**，让你在用 `on`/`emit` 这些事件方法时有更智能的类型推断（比如参数类型、事件名自动补全）。
- **运行时**：这段代码**不会影响运行时行为**，只影响类型检查和编辑器提示。
- **前提**：你的 `LoginWindow` 类本身继承自 `EventEmitter`（或间接继承），已经有了 `on`/`emit` 的实现。

### 为什么注释掉没影响？

- 只要你不依赖于事件方法的类型推断（比如你用 `on('login-success', ...)` 时不在意参数类型），注释掉不会报错。
- TypeScript 只会在你需要类型推断时才用到这段声明，没用到就没影响。
- 你的 `LoginWindow` 继承自 `BaseWindow`，而 `BaseWindow` 又继承自 `EventEmitter`，所以 `on`/`emit` 方法本身就有实现和基础类型。

### 什么时候需要它？

- 如果你希望在写 `loginWindow.on('login-success', (user) => {...})` 时，`user` 能自动获得类型提示，就需要这段类型声明。
- 如果你不在意类型推断，或者事件参数类型很简单，可以不用。

---

**总结：**
- 这段代码只影响类型提示，不影响运行。
- 注释掉不会影响功能，只会让事件方法的类型推断变弱。
- 如果你想要更智能的事件类型提示，可以用更安全的泛型继承方式（见上文最佳实践）。

如需事件类型推断的最佳实践写法，可以继续提问！

# 更优雅的实现方式

你遇到的 ESLint 报错：

> Unsafe declaration merging between classes and interfaces.eslint@typescript-eslint/no-unsafe-declaration-merging

是因为你在 TypeScript 里用了**类和同名接口的声明合并**，如下：

```typescript

/**
 * 窗口事件类型
 */
export interface WindowEvents {
  'window-ready': () => void;
  'window-closed': () => void;
  'window-minimized': () => void;
  'window-maximized': () => void;
  'window-restored': () => void;
  'window-focused': () => void;
  'window-blurred': () => void;
}

/**
 * 登录窗口事件类型
 */
export interface LoginWindowEvents extends WindowEvents {
  'login-success': (userData: any) => void;
  'login-failed': (error: string) => void;
  'login-cancelled': () => void;
  
}

export class LoginWindow extends BaseWindow implements ILoginWindow {
  // ...
}

// 为了TypeScript类型检查，扩展EventEmitter的类型
export declare interface LoginWindow {
  on<U extends keyof LoginWindowEvents>(
    event: U,
    listener: LoginWindowEvents[U]
  ): this;
  emit<U extends keyof LoginWindowEvents>(
    event: U,
    ...args: Parameters<LoginWindowEvents[U]>
  ): boolean;
}
```

---

## 1. **什么是声明合并？**

TypeScript 允许你为同一个名字声明多次 interface/class/type，编译时会自动合并它们的成员。这常用于为类“补充”类型签名，尤其是为类添加事件类型（如 Node.js 的 EventEmitter）。

---

## 2. **为什么 ESLint 报警？**

- 这种写法虽然 TypeScript 支持，但**容易出错**，比如类和接口的成员定义不一致时，类型系统不会报错，运行时也不会有任何提示。
- 在多人协作、复杂继承、自动化 refactor 时，这种“隐式扩展”会让代码难以维护和理解。
- 因此，`@typescript-eslint/no-unsafe-declaration-merging` 规则建议**不要用这种方式**。

---

## 3. **如何安全地实现同样的功能？**

### **推荐做法：用类继承泛型或类型断言**

#### **方案一：直接在类上声明事件方法**

如果你的 `BaseWindow` 已经继承自 `EventEmitter`，你可以直接在类体内声明 `on` 和 `emit` 方法的重载：

```typescript
export class LoginWindow extends BaseWindow implements ILoginWindow {
  // ...你的方法...

  // 事件类型重载
  public override on<U extends keyof LoginWindowEvents>(
    event: U,
    listener: LoginWindowEvents[U]
  ): this {
    return super.on(event, listener);
  }
  public override emit<U extends keyof LoginWindowEvents>(
    event: U,
    ...args: Parameters<LoginWindowEvents[U]>
  ): boolean {
    return super.emit(event, ...args);
  }
}
```

#### **方案二：用类型断言扩展实例类型**

如果只是为了类型提示，可以在用到实例的地方断言：

```typescript
const win = new LoginWindow() as LoginWindow & {
  on<U extends keyof LoginWindowEvents>(
    event: U,
    listener: LoginWindowEvents[U]
  ): typeof win;
  emit<U extends keyof LoginWindowEvents>(
    event: U,
    ...args: Parameters<LoginWindowEvents[U]>
  ): boolean;
};
```

#### **方案三：用泛型继承（推荐 EventEmitter 事件类型）**

如果你的 `BaseWindow` 继承自 `EventEmitter`，可以用泛型指定事件类型：

```typescript
import { EventEmitter } from 'events';

export class BaseWindow<TEvents = any> extends EventEmitter {
  // ...
}

export class LoginWindow extends BaseWindow<LoginWindowEvents> implements ILoginWindow {
  // ...
}
```
这样 `on` 和 `emit` 都会自动获得类型提示。

---

## 4. **如何修复你的代码？**

**移除声明合并，直接在类体内声明事件方法，或用泛型继承。**

### 示例修正（泛型继承推荐）：

```typescript
// baseWindow.ts
export abstract class BaseWindow<TEvents = any> extends EventEmitter {
  // ...
}

// loginWindow.ts
export class LoginWindow extends BaseWindow<LoginWindowEvents> implements ILoginWindow {
  // ...无需再写 declare interface LoginWindow ...
}
```

---

## 5. **总结**

- **声明合并**虽然能用，但有安全隐患，ESLint 建议不用。
- 推荐用**泛型继承**或**类体内重载**来实现事件类型扩展，类型安全且易维护。
- 这样不会再被 ESLint 报警，类型提示也更清晰。

如需具体迁移代码示例，请告知你的 `BaseWindow` 继承结构和事件需求！